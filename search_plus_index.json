{"./":{"url":"./","title":"介绍","keywords":"","body":"anu npm install anujs anu, 读作［安努］，原意为苏美尔的主神。 此框架的创立之意有三： 提升性能， 虽然React的性能相对于传统的MVVM框架是很厉害了，但近几年冒出来的diff算法比官方版更优秀，官方版积重难返，很难短时期吸收这些成果。anu则小船好调头，第一时间收纳其中。性能是王道。天下武功，唯快不破。 压缩体积。 React+React-dom加起来有三万多行，这么大的体量任何code splitting与按需加载技术都无能为力，因此我们需要迷你版的体积。 卓越的浏览器兼容性。 React在生产环境中没有用到什么新式偏门的API，因此本来就可以兼容到IE8之下。兼容性越好，我们的后顾之忧越少。 －－－－－－－－－－ 特点： 支持React的无狀态组件，纯组件，高阶组件，受控组件与非受控组件， 命名空间就是React，此外还暴露了另一个别名ReactDOM在window上 体积足够少(1700行相对于react+react-dom的3万行) 性能是官方React的近两倍或更高 测试页面、 结果统计 生命周期函数的参数与官方保持一致 直接与react-redux, react-router-dom, react-router-redux混用 支持后端渲染 支持官方的chrome DevTools 详细用法与示例见 wiki class A extends React.PureComponent { constructor(props) { super(props) this.state = { aaa: { a: 7 } } } click() { this.setState(function(state){ state.aaa.a = 8 }) } render() { return {this.state.aaa.a} } } window.onload = function () { ReactDOM.render(, document.getElementById('example')) } 这个怎么点击也不会变 与Redux使用的例子 var addTodoActions = function (text) { return { type: 'add_todo', text: text }; } var todoReducer = function (state, action) { if (typeof state === 'undefined') { return []; } switch (action.type) { case 'add_todo': return state.slice(0).concat({ text: action.text, completed: false }); break; default: return state; } }; var store = Redux.createStore(todoReducer); class App extends React.Component { constructor(props){ super(props) this.state = { items: store.getState() } this.onChange = this.onChange.bind(this) this.handleKeyUp = this.handleKeyUp.bind(this) this.handleAdd = this.handleAdd.bind(this) } componentDidMount(){ var unsubscribe = store.subscribe(this.onChange); } onChange(){ this.setState({ items: store.getState() }); } handleKeyUp(e){ if(e.which === 13){ this.handleAdd() } } handleAdd(){ var input = this.refs.todo var value = input.value.trim(); if(value) store.dispatch(addTodoActions(value)); input.value = ''; } render(){ return ( 点击添加 {this.state.items.map(function(item){ return {item.text}; })} ); } }; ReactDOM.render( , document.getElementById('example') ); 测试 测试 依赖于 + [selenium-server-standalone](http://selenium-release.storage.googleapis.com/3.3/selenium-server-standalone-3.3.1.jar) + [chromedriver](https://sites.google.com/a/chromium.org/chromedriver/), [more available drivers](http://www.seleniumhq.org/projects/webdriver/) + nodejs v6.10.0+ + karma cli npm install selenium-standalone selenium-standalone install --config=./s.js selenium-standalone start //另开窗口 npm run build 或者 //linux32可以改成mac, window wget https://chromedriver.storage.googleapis.com/2.29/chromedriver_linux32.zip unzip chromedriver_linux32.zip wget http://selenium-release.storage.googleapis.com/3.3/selenium-server-standalone-3.3.1.jar java -jar selenium-server-standalone-3.3.1.jar //另开窗口 npm run build Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"install.html":{"url":"install.html","title":"安装","keywords":"","body":"安装 npm i anujs Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"warn.html":{"url":"warn.html","title":"注意事项","keywords":"","body":"注意点 目前没有支持的方法与对象 PropTypes childContextTypes(不需要定义它，就能使用context) Children的方法集合（不完整） mixin机制 createClass cloneElement isValidElement createFactory 低版本浏览器可能需要以下 语言补丁 Array.isArray Object.assign JSON.stringify console-polyfill es6-Map 或者直接使用polyfill.js https://github.com/RubyLouvre/anu/tree/master/dist/polyfill.js Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"jsx.html":{"url":"jsx.html","title":"JSX","keywords":"","body":"JSX React的核心机制之一就是可以在内存中创建虚拟DOM。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 为了方便使用虚拟DOM，React发明了JSX， 可以简单地理解它是一种在JS中编写与XML类似的语言。通过JSX来声明组件的属性，类型与结果，并且通过｀{}`插值，套嵌JS逻辑与子级的JSX。 要JSX语法，你必须要引入babel的JSX解析器，把JSX转化成JS语法，这个工作会由babel自动完成。同时引入babel后，你就可以使用新的es6语法，babel会帮你把es6语法转化成es5语法，兼容更多的浏览器。 大家可以在这里下载最新版babel http://www.bootcdn.cn/babel-core/ JSX的特点： 类XML语法容易接受，结构清晰 增强JS语义 抽象程度高，屏蔽DOM操作，跨平台 代码模块化 我们从最简单的一个官网例子helloworld开始： Hello React! ReactDOM.render( Hello, world!, document.getElementById('example') ); script标签里面的内容实际会被编译成 ReactDOM.render( React.createElement('h1',null, 'Hello, world!'), document.getElementById('example') ); 又如 var root =( First Text Content Second Text Content ); 会被编译成 var root = React.createElement('ul', { className: 'my-list' }, React.createElement('li', null, 'First Text Content'), React.createElement('li', null, 'Second Text Content') ); JSX语法介绍 ｀{}`插值是让JSX区别普通HTML的一个重要特性，只有三个地方可以使用它。可以放属性名的地方，属性等于号之后的位置及innerHTML之间。 1.可以放属性名的地方, 这里只能使用JSXSpreadAttribute(延伸属性)， 换言之，括号内必须带三个点号 var props = {}; props.foo = x; props.bar = y; var component = ; 2.属性等于号之后的位置, JSX的属性值必须用引号括起来，当你将引号改成花括号，它里面就可以使用JSX变量了。相当于其他框架的绑定属性或指令。需要说明一下，HTML的固有属性必须使用JS形式，保持驼峰风格，如class要用className代替，for要用htmlFor代替，tabindex要用tabIndex代替，colspan要用colSpan代替。 花括号里面可以使用三元表达式 var person = ; 会编译成 var person = React.createElement( Person, {name: window.isLoggedIn ? window.name : ''} ); 3.innerHTML xxx{111}yyy 这个会编译成, 相邻的字任串或数字会合并成一个字符串，布尔，null, undefined会被忽略掉。 React.createElement('div',null,\"xxx111yyy\") 在innerHTML里面，我们可以使用数组或数组的map方法生成一个新数组的方法，为当前父元素添加一堆子元素。 var ul = ( { this.todoList.todos.map(function (todo) { return ( {todo.text} ); }) } ); JSX中绑定事件 JSX让事件直接绑定在元素上。 Submit 和原生HTML定义事件的唯一区别就是JSX采用驼峰写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。 React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。 JSX中使用样式 在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，`属性值不能是字符串而必须为对象｀。 Hello World. 或者 var style = { color: '#ff0000', fontSize: '14px' }; var node = HelloWorld.; 要明确记住,{}里面是JS代码,这里传进去的是标准的JS对象。在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，例如“background-color”变为“backgroundColor”, “font-size”变为“fontSize”，这和标准的JavaScript操作DOM样式的API是一致的。 HTML转义 在组件内部添加html代码,并将html代码渲染到页面上。React默认会进行HTML的转义，避免XSS攻击， 如果要不转义，可以使用dangerouslySetInnerHTML属性。dangerouslySetInnerHTML要求对应一个对象，里面有一个叫__html的字符串。React故意搞得这么难写，目的让大家少点用它。 var content='content'; React.render( , document.body ); 注意：JSX里面br，input, hr等标签必须自闭合，如必须写成 自定义组件 组件定义之后，可以利用XML语法去声明，而能够使用的XML Tag就是在当前JavaScript上下文的变量名,该变量名就是组件名称。 一般来说，我们可以通过标签名的第一个字母是大写还是小写来识别组件与普通标签。 class HelloWorld extends React.Component{ render() { return ( Hello, ! It is {this.props.date.toTimeString()} ); } }; setInterval(function() { ReactDOM.render( , document.getElementById('example') ); }, 500); Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"component.html":{"url":"component.html","title":"组件","keywords":"","body":"组件 自从chrome推出web component后，将组件实现标签化的思潮又一次回到我们眼前。上一次是JSP时代。 React/anu中使用组件非常简单，就是将标签名改成类名就行了。 React也经过几次迭代，定义组件的方式改成es6的class来定义组件，只要求它继续React.Component类及添加一个render方法就行了。但这个也不是必须的，因为后来出现了无状态组件。让我们梳理一下React定义组件的三种方式吧，分别有 有状态组件，纯组件，无状态组件。 1.有状态组件 class Input extends React.Component{ constructor(props){ super(props) this.state = { value: 'xxx' } this.onChange = this.onChange.bind(this) } onChange(e){ this.setState( value: e.target.value ) } render(){ return } } ReactDOM.render(, rootElement) 2.纯组件 纯数组与有状态组件唯一不同就是其父类。父类为它指定了特殊的shouldComponentUpdate。当用户调用了setState，或父组件发生render操作时，子组件也会发生render操作，这时我们可以指定shouldComponentUpdate方法，通过返回false阻止此组件进行更新。 为了减少无效的更新操作，shouldComponentUpdate的实现是非常关键的，因此在早期React版本中有一个叫PureRenderMixin插件非常受欢迎。返回此组件就整合到React中，诞生了现在的纯组件。 class Input extends React.PureComponent{ constructor(props){ super(props) this.state = { value: 'xxx' } this.onChange = this.onChange.bind(this) } onChange(e){ this.setState( value: e.target.value ) } render(){ return } } ReactDOM.render(, rootElement) 3.无状态组件 一个数组是总继承什么父类，必须消耗许多性能，并且在组件挂载到DOM树或更新过程中，会触发一系列生命周期钩子，这也会消耗性能。为了避开所有这一切的性能损失，于是React推出了无状态组件。无状态组就是一个普通的函数，特殊之处是函数的第一个字母大写，接受两个参数(props与context)，返回JSX。 function Input (props, context){ return } ReactDOM.render(, rootElement) 组件的属性与方法 当我们继承React.Component或React.PureComponent时，会获得一些对象与方法。首先是4个对象，props, state, context, refs与一些改变组件状态的方法，setState, forceUpdate及生命周期钩子。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"props.html":{"url":"props.html","title":"Props","keywords":"","body":"props props是用来描述组件的外部状态，并且能往下传递的，通常来说，props里面还存在一个children数组，如果不存在子组件，也可以不用写。为了性能起见，props变设计成不可改变，只能在JSX 里使用attributes形式进行定义。 class HelloMessage extends React.Component{ render: function() { //这里的props就等于rubylouvre return Hello {this.props.name}; } } ReactDOM.render( , document.getElementById('example') 默认属性 为了减少最终使用组件的用户的工作量，我们可以在类名里添加一个对象，来集中定义默认属性。 class Parent extends React.Component { render() { return () } } Parent.defaultProps = { name: '我在这里' } function HelloComponent(props, context) { return (Hello {props.name}) } window.onload = function() { ReactDOM.render(, document.getElementById('example')); } 这个默认会被清掉 你也可以使用静态的访问器属性 class Parent extends React.Component { static defaultProps = { name: \"静态\" } render() { return () } } function HelloComponent(props, context) { return (Hello {props.name}) } window.onload = function() { ReactDOM.render(, document.getElementById('example')); } 这个默认会被清掉 如果你安装了bable这个babel-plugin-transform-class-properties插件，还可以这样写 https://www.npmjs.com/package/babel-plugin-transform-class-properties class Parent extends React.Component { static get defaultProps() { return { name: \"静态\" } } render() { return () } } function HelloComponent(props, context) { return (Hello {props.name}) } window.onload = function() { ReactDOM.render(, document.getElementById('example')); } 这个默认会被清掉 属性验证 在开发环境中，我们可以PropTypes 提供的许多验证器 (validator) 来检查传入数据的有效性。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。下面用例子来说明不同验证器的区别： class Hello extends Component { render(){ return ( hello { this.props.name } ); } } Hello.propTypes ＝ { // 可以声明 prop 为指定的 JS 基本类型。默认 // 情况下，这些 prop 都是可传可不传的。 optionalArray: React.PropTypes.array, optionalBool: React.PropTypes.bool, optionalFunc: React.PropTypes.func, optionalNumber: React.PropTypes.number, optionalObject: React.PropTypes.object, optionalString: React.PropTypes.string, // 所有可以被渲染的对象：数字， // 字符串，DOM 元素或包含这些类型的数组。 optionalNode: React.PropTypes.node, // React 元素 optionalElement: React.PropTypes.element, // 用 JS 的 instanceof 操作符声明 prop 为类的实例。 optionalMessage: React.PropTypes.instanceOf(Message), // 用 enum 来限制 prop 只接受指定的值。 optionalEnum: React.PropTypes.oneOf(['News', 'Photos']), // 指定的多个对象类型中的一个 optionalUnion: React.PropTypes.oneOfType([ React.PropTypes.string, React.PropTypes.number, React.PropTypes.instanceOf(Message) ]), // 指定类型组成的数组 optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number), // 指定类型的属性构成的对象 optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number), // 特定形状参数的对象 optionalObjectWithShape: React.PropTypes.shape({ color: React.PropTypes.string, fontSize: React.PropTypes.number }), // 以后任意类型加上 `isRequired` 来使 prop 不可空。 requiredFunc: React.PropTypes.func.isRequired, // 不可空的任意类型 requiredAny: React.PropTypes.any.isRequired, // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接 // 使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。 customProp: function(props, propName, componentName) { if (!/matchme/.test(props[propName])) { return new Error('Validation failed!'); } } } 在React 15.5中，主 React.PropTypes已经被剥离到独立的仓库中。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"state.html":{"url":"state.html","title":"State","keywords":"","body":"State state的作用 state是React中组件的一个对象。React把用户界面当做是状态机，想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致。 React中，更新组件的state，会导致重新渲染用户界面(不要操作DOM)。简单来说，就是用户界面会随着state变化而变化。 state工作原理 常用的通知React数据变化的方法是调用setState(data,callback)。这个方法会合并data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调.大部分情况不需要提供callback,因为React会负责吧界面更新到最新状态. 那些组件应该有state? 大部分组件的工作应该是从props里取数据并渲染出来。但是，有时需要对用户输入，服务器请求或者时间变化等作出响应，这时才需要state。 组件应该尽可能的无状态化，这样能隔离state，把它放到最合理的地方(Redux做的就是这个事情?)，也能减少冗余并易于解释程序运作过程。 常用的模式就是创建多个只负责渲染数据的无状态(stateless)组件，在他们的上层创建一个有状态(stateful)组件并把它的状态通过props 传给子级。有状态的组件封装了所有的用户交互逻辑，而这些无状态组件只负责声明式地渲染数据. 哪些应该作为state? state应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据。这中数据一般很小且能被JSON序列化。当创建一个状态化的组件的时候， 应该保持数据的精简，然后存入this.state。在render()中在根据state来计算需要的其他数据。因为如果在state里添加冗余数据或计算 所得数据，经常需要手动保持数据同步。 那些不应该作为state? this.state应该仅包括能表示用户界面状态所需要的最少数据。因此，不应该包括： 计算所得数据 React组件, 在render()里使用props和state来创建它。 基于props的重复数据。 尽可能保持用props来做作为唯一的数据来源.把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化. setState的操作时机 componentDidMount钩子 componentWillReceiveProps钩子 事件回调 setTimeout回调 在组件的其他生命周期钩子里操作setState可能引起不断更新组件自身，导致页面僵死！ Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"context.html":{"url":"context.html","title":"Context","keywords":"","body":"context 在React中，数据总是自上而下的传递，每当你使用一个组件的时候，你可以看到组件的props属性会自上而下的传递。 但是如果一个页面结构非常复杂，你在在某一种子组件获得其祖先组件的某个属性来干某事时，就非常麻烦了。虽然在React内部存在一个叫 _hostParent的属性，类似于DOM的parentNode来让你回溯其祖先，但毕竟是没有记录在文档上的内部属性，不适宜使用它。 于是到context出场了。 在官方React中，context一般与getChildContext,childContextTypes一起使用。在anu中，所有数据验证的东西已经干掉， 因此只要用context、getChildContext就行了。 class Parent extends React.Component{ render() { return () } } class Son extends React.Component{ render() { return ( {this.context.value} ) } } class App extends React.Component{ getChildContext() { return { value: 666 }; } render() { return () } }; window.onload = function() { ReactDOM.render(, document.getElementById('example')); } 这个默认会被清掉 React的context和全局变量相似，应避免使用，场景包括：传递登录信息、当前语音以及主题信息； 如果只传递一些功能模块数据，则尽量不要使用context，使用props传递数据会更加清晰； 使用context会使组件的复用性降低，因为这些组件依赖'上下文'，当你在别的地方渲染的时候，可能会出现差异； Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"refs.html":{"url":"refs.html","title":"Refs","keywords":"","body":"refs 在组件实例中，存在一个叫refs的对象，在组件render时，框架会将JSX中定义了ref属性的标签对应的DOM节点或实例收集到这个对象。 当ref为一个字符串时，其所在标签的tagName是小写，那么它就会收集其DOM节点，如果标签名是大写开头，那么就会收集其组件实例。 class Com extend React.Component{ render(){ return } } var s = ReactDOM.render(, document.body) console.log(s.refs.input) //返回input这个真实DOM 此外，ref也可以是一个函数，这时它的传参就是DOM节点或组件实例，它会在组件挂载或卸载时各执行一次，然后在ref对应的函数发生变化时也会执行一次。 在卸载时，传参总是为null function TestComp(props){ let refDom; return ( refDom = node}> ... ) } 值得注意的是，无状态组件由于没有实例，因此不会对 ref进行任何处理。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"lifecycle.html":{"url":"lifecycle.html","title":"生命周期","keywords":"","body":"组件的生命周期钩子 React的组件机制非常出色，不仅在于其标签化的设计，还在于它的生命周期非常完整，在每个阶段都有不同的钩子供你调用。 早期一共有10个钩子，在es6类流行后，精简为8个，getDefaultProps 与 getInitialState被废弃了。 我们可以把组件生命周期大致分为三个阶段： 第一阶段：是组件挂载阶段 getDefaultProps 或es6 Class.defaultProps getInitialState 或es6 this.state componentWillMount render componentDidMount 第二阶段：是组件在运行和交互阶段 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 第三阶段：是组件卸载阶段 componentWillUnmount 说明 componentWillMount() 在完成首次渲染之前调用，此时仍可以修改组件的state。 render() 必选的方法，创建虚拟DOM，该方法具有特殊的规则： 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件（不能返回数组） 不能改变组件的状态 不能修改DOM的输出 componentDidMount() 真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。 在服务端中，该方法不会被调用。 componentWillReceiveProps(nextProps, parentContext) 组件接收到上面传下来的props, context做参数，大家可以在这里进行setState操作 componentWillReceiveProps: function(nextProps) { if (nextProps.bool) { this.setState({ bool: true }); } } shouldComponentUpdate(nextProps, nextState, parentContext) 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。 在出现应用的瓶颈时，可通过该方法进行适当的优化。 在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用 componentWillUpdate 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 componentDidUpdate 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 componentWillUnmount 组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销， 比如创建的定时器或添加的事件监听器。 生命周期 调用次数 能否使用 setSate() componentWillMount 1 是 render >=1 否 componentDidMount 1 是 componentWillReceiveProps >=0 是 shouldComponentUpdate >=0 否 componentWillUpdate >=0 否 componentDidUpdate >=0 否 componentWillUnmount 1 否 class LifeCycle extends React.Component { constructor(props) { super(props); alert(\"Initial render\"); alert(\"constructor\"); this.state = {str: \"hello\"}; } componentWillMount() { alert(\"componentWillMount\"); } componentDidMount() { alert(\"componentDidMount\"); } componentWillReceiveProps(nextProps) { alert(\"componentWillReceiveProps\"); } shouldComponentUpdate() { alert(\"shouldComponentUpdate\"); return true; // 记得要返回true } componentWillUpdate() { alert(\"componentWillUpdate\"); } componentDidUpdate() { alert(\"componentDidUpdate\"); } componentWillUnmount() { alert(\"componentWillUnmount\"); } setTheState() { let s = \"hello\"; if (this.state.str === s) { s = \"HELLO\"; } this.setState({ str: s }); } forceItUpdate() { this.forceUpdate(); } render() { alert(\"render\"); return( {\"Props:\"}{parseInt(this.props.num)} {\"State:\"}{this.state.str} ); } } class Container extends React.Component { constructor(props) { super(props); this.state = { num: Math.random() * 100 }; } propsChange() { this.setState({ num: Math.random() * 100 }); } setLifeCycleState() { this.refs.rLifeCycle.setTheState(); } forceLifeCycleUpdate() { this.refs.rLifeCycle.forceItUpdate(); } unmountLifeCycle() { // 这里卸载父组件也会导致卸载子组件 React.unmountComponentAtNode(document.getElementById(\"container\")); } parentForceUpdate() { this.forceUpdate(); } render() { return ( propsChange setState forceUpdate unmount parentForceUpdateWithoutChange ); } } ReactDom.render( , document.getElementById('container') ); Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"event.html":{"url":"event.html","title":"事件","keywords":"","body":"事件系统 早期的DOM 0事件系统，是在标签内直接添加 onxxx=\"fn\"属性，这有巨大的缺点： 一是只能应用于冒泡阶段 二是fn为全局函数 三是this与事件对象存在兼容性问题 但onxxx方法非常明了，因此React对它做了一些改进， onClick属性可以在后面添加Capture字样，让它在捕获阶段执行，即onClick对应着onClickCapture， onChange对应着onChangeCapture 回调函数通过编译手段，将它改成局部 回调的this指向组件实例，事件对象框架做了标准化处理，并且通过回收机制，不断重复使用此方法。 点我 在React.createClass时代，组件的回调函数都是自动bind this，保持它们总是指向实例本身。但是在es6时，则没有这个免费服务了。 你可以通过｀babel-plugin-transform-class-properties`这插件， 实现在class块中直接使用箭头函数。众所周知， 箭头函数是autobind this的 let {Component, PropTypes} = React; export default class MyComponent extends Component { // lifecycle methods and statics static propTypes = { foo: PropTypes.bool.isRequired } handler = (e) => { ... } // render actual DOM output render() { return ; } } 此外你也可以使用autobind-decorator这个模块，直接用es7的注解 搞定这个问题 https://github.com/andreypopp/autobind-decorator import autobind from 'autobind-decorator' class Component { constructor(value) { this.value = value } @autobind method() { return this.value } } let component = new Component(42) let method = component.method // .bind(component) isn't needed! method() // returns 42 // Also usable on the class to bind all methods @autobind class Component { } Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"uncontrolledComponent.html":{"url":"uncontrolledComponent.html","title":"受控组件与非受控组件","keywords":"","body":"受控组件与非受控组件 一些表单元素，如select, textarea, input存在受控与非受控之分。受控就是用户可以通过点击，输入，选择等行为来控制其value/checked的改变，非受控则反之。 value, checked是表单元素两个很特殊的属性，决定着元素的外观。 当用户为表单元素指定了value, checked属性，那么框架就会进一步判定用户有没有定义其他用于控制它改变的属性与事件，比如说disabled, readOnly, onChange, onClick, onInput。如果有，它就是受控组件，没有就是非受控组件。 非受控组件的情况下，框架会在内部添加一些事件，阻止用户手动改变value/checked，这时用户只能通过setState来改变。 强烈建议，表单元素一定要弄成受控组件。 否则你不要使用value/checked，而是改用defaultValue/defaultChecked。 var textarea, radio, text, select, checkbox window.onload = function(){ class Text extends React.Component{ constructor(props) { super(props); this.state={value:'Hello'}; this.handleChange=this.handleChange.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } render() { var value = this.state.value; return ; } } class Checkbox extends React.Component{ constructor(props) { super(props); this.state={checked: false}; this.handleChange=this.handleChange.bind(this); } handleChange(event) { this.setState({checked: event.target.checked}); } render() { var value = this.state.value; return ; } } class Radio extends React.Component{ constructor(props) { super(props); this.state={checked: false}; this.handleChange=this.handleChange.bind(this); } handleChange(event) { this.setState({checked: event.target.checked}); } render() { var value = this.state.value; return } } class TextArea extends React.Component{ constructor(props) { super(props); this.state={value: 'dddd'}; this.handleChange=this.handleChange.bind(this); } handleChange(event) { this.setState({value: event.target.checked}); } render() { return } } class Select extends React.Component { constructor() { super() this.state = { value: 'bbb' } } render() { return aaa bbb ccc } } text = ReactDOM.render( , document.getElementById('text') ) checkbox = ReactDOM.render( , document.getElementById('checkbox') ) radio = ReactDOM.render( , document.getElementById('radio') ) textarea = ReactDOM.render( , document.getElementById('textarea') ) select = ReactDOM.render( , document.getElementById('select') ) } 各种非受控组件 注意，多选下拉框的value应该对应一个数组。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"ani.html":{"url":"ani.html","title":"动画","keywords":"","body":"动画 建议使用React Motion这个动画库 https://github.com/chenglou/react-motion Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"debug.html":{"url":"debug.html","title":"调试","keywords":"","body":"调试 anu完全兼容官方的chrome开发者工具 先到这里 然后 .aaa { width: 200px; height: 200px; background: red; } .bbb { width: 200px; height: 200px; background: lawngreen; } class App extends React.Component { constructor(props) { super(props) this.state = { aaa: 'aaa' } } change(a){ this.setState({ aaa:a }) } componentDidMount(){ console.log('App componentDidMount') } componentWillUpdate(){ console.log('App componentWillUpdate') } render() { return this.state.aaa === 'aaa' ? : } } class Inner extends React.Component{ constructor(props){ super(props) } componentWillMount(){ console.log('Inner componentWillMount') } componentDidMount(){ console.log('Inner componentDidMount') } componentWillUpdate(){ console.log('Inner componentWillUpdate') } componentDidUpdate(){ console.log('Inner componentDidUpdate') } componentWillUnmount(){ console.log('Inner componentWillUnmount') } render() { return xxx } } class Inner2 extends React.Component{ constructor(props){ super(props) } componentWillMount(){ console.log('Inner2 componentWillMount') } componentDidMount(){ console.log('Inner2 componentDidMount') } componentWillUpdate(){ console.log('Inner2 componentWillUpdate') } componentWillUnmount(){ console.log('Inner2 componentWillUnmount') } render() { return yyy } } var s window.onload = function(){ s = ReactDOM.render( , document.getElementById('example')) } 开发者工具 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"ssr.html":{"url":"ssr.html","title":"后端渲染","keywords":"","body":"服务端渲染 准备动作 1、安装nodejs与安装express 　　安装nodejs教程:http://www.cnblogs.com/pigtail/archive/2013/01/08/2850486.html 　　安装express教程:http://www.expressjs.com.cn/starter/installing.html 2、安装node-jsx（使nodejs支持jsx语法） 　　$ npm install node-jsx 3、安装ejs模板引擎 　　$ npm install ejs 在项目中建立一个app.js，输入 var express = require('express'); var app = express(); app.get('/', function (req, res) { res.send('Hello World!'); }); var server = app.listen(3000, function () { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 通过如下命令启动此应用： $ node app.js 打开浏览器，输入localhost:3000就看到效果了。 使用模板引擎，我们在建立一个test目录，里面再建一个views目录，模块文件都放里面。 var express = require(\"express\"); var app = express(); //指定模板引擎 app.set(\"view engine\", 'ejs'); //指定模板位置 app.set('views', __dirname + '/test/views'); //利用模板文件home.ejs渲染为html app.get(\"/\", function(req, res) { res.render('home.ejs', { name: '司徒正美' }); }); var server = app.listen(3000, function() { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 然后我们模块home.ejs my ejs template Hi 如果你嫌弃ejs后缀文件，你的编辑器无法别识（没有语法高亮），可以改进一下，将home.ejs改为home.html var express = require(\"express\"); var app = express(); //指定模板引擎 var ejs = require('ejs'); app.set(\"view engine\", 'ejs'); //指定模板位置 app.set('views', __dirname + '/test/views'); //使用ejs模板引擎解析html视图文件 app.engine('.html',ejs.__express); //利用模板文件home.ejs渲染为html app.get(\"/\", function(req, res) { res.render('home.html', {//这里指定文件名 name: '司徒正美' }); }); var server = app.listen(3000, function() { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 我们先看一下官方react15.3如何实现后端渲染的 npm install react npm install react-dom 在Test目录下建立一个components目录，里面建一个Test.js，表示这里是一个类 var React=require(\"react\"); class Test extends React.Component{ render(){ return {this.props.name}; } } module.exports = Test 然后修改app.js var express = require(\"express\"); var app = express(); //指定模板引擎 var ejs = require('ejs'); app.set(\"view engine\", 'ejs'); //指定模板位置 app.set('views', __dirname + '/test/views'); //使用ejs模板引擎解析html视图文件 app.engine('.html',ejs.__express); //................ //安装\"node-jsx\"，安装该模块可以使nodejs兼容jsx语法 require(\"node-jsx\").install() var React = global.React = require(\"react\"); var ReactDOMServer = require('react-dom/server') var Test = require('./test/component/Test.js') //引入React组件 //利用模板文件home.ejs渲染为html app.get(\"/\", function(req, res) { res.render('home.html', {//这里指定文件名 component: ReactDOMServer.renderToString( React.createElement( Test,{name:\"司徒正美\"}) ) }) }) //................ var server = app.listen(3000, function() { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 然后将模板改一下 react 后端渲染 如果想使用anu的后端渲染方案，主要改一下链接就是 var express = require(\"express\"); var app = express(); //指定模板引擎 var ejs = require('ejs'); app.set(\"view engine\", 'ejs'); //指定模板位置 app.set('views', __dirname + '/test/views'); //使用ejs模板引擎解析html视图文件 app.engine('.html',ejs.__express); //................ //安装\"node-jsx\"，安装该模块可以使nodejs兼容jsx语法 require(\"node-jsx\").install() var React = global.React = require(\"./dist/React\"); //var ReactDOMServer = require('react-dom/server') var ReactDOMServer = require('./dist/ReactDOMServer') var Test = require('./test/components/Test.js') //引入React组件 //利用模板文件home.ejs渲染为html app.get(\"/\", function(req, res) { res.render('home.html', {//这里指定文件名 component: ReactDOMServer.renderToString( React.createElement( Test,{name:\"司徒正美\"}) ) }) }) //................ var server = app.listen(3000, function() { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 但现在前端是一个静态页面，没有JS ，我们让它能活动起来 设置一下静态资态的目录，我把React.js, babel.js什么放到这里上 //app.js app.use(express.static('dist')); 重写一下Test目录，让它有事件 var React=require(\"../../dist/React\"); class Test extends React.Component{ click(){ console.log('=========') } render(){ return {this.props.name} 事件 ; } } module.exports = Test home.html也改一下 react 后端渲染 class Test extends React.Component{ click(){ console.log('=========') } render(){ return {this.props.name} 事件 ; } } window.onload = function(){ ReactDOM.render(, document.getElementById('container')) } 这个后端渲染与前端渲染有什么区别呢？后端渲染会为你的根组件生成的标签添加两个属性data-reactroot与 data-react-checksum。其中后者是为了兼容官网React，anu只需要前者就行了。在前端的ReactDOM.render方法里面，anu会检测插入位置的所有直接孩子，判定它有没有data-reactroot属性，有则进入对齐模式。对齐模式与传统的创建模式不一样。 创建模式是根据虚拟DOM创建一棵真实DOM树，然后移除原容器的所有孩子，插入其中。 对齐模式是因为后端已经将所有孩子直接创建好，但可能会多出一些文本节点。这时它只根据虚拟DOM 的type与真实DOM 的node.toLowerCase()进行比较就是。速度肯定快上几个数量级。 而在实际项目中，我们可以通过babel将Test（会去掉里面的module.export = Test）及其他代码进行打包，不会直接写在页面上的。这样一来 ,就可以达到前后共享一套代码。 https://cnodejs.org/topic/5660f8f9d0bc14ae27939b37 http://blog.csdn.net/mqy1023/article/details/55051788 http://imweb.io/topic/5547892e73d4069201d83e6c http://blog.techbridge.cc/2016/08/27/react-redux-immutablejs-node-server-isomorphic-tutorial/ https://blog.coding.net/blog/React-Server-Side-Rendering-for-SPA-SEO Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"router.html":{"url":"router.html","title":"路由","keywords":"","body":"路由器 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"ui.html":{"url":"ui.html","title":"组件库","keywords":"","body":"ui库 建议使用React现成的庞大UI库资源 https://www.zhihu.com/question/39452825?sort=created Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "},"ie.html":{"url":"ie.html","title":"旧式IE的支持","keywords":"","body":"旧式IE的支持 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-06-07 11:18:52 "}}